---
title: 알고리즘 Expert 4014 활주로 건설
description: 알고리즘 Expert 4014 활주로 건설
categories:
 - 알고리즘  
tags:
---
### 문제 분석 요약  
지형이 높이가 다른데 X길이 만큼의 활주로를 세워서 양끝으로 이동이 가능한지 체크하는 문제  
그렇게 가능한 열 or 행이 몇개가 되는지 세어주면됨

### 알고리즘 설계  
경우의 수가 필요하다
1. 숫자가 연속하는 경우
2. 연속하지 않는 경우  
- 높이가 1 차이 나는 경우
  - 올라가야 하는경우
  - 내려가야 하는 경우
- 1 이상 차이나는 경우  

경우를 다 살펴보고 성공한 경우가 어떤건지 찾는것보다  
실패한 경우에 false처리를 하고 실패하지 않은 경우의 개수를 세는 것이 더 구현하기 쉽다  


### 구현순서  
### 코드  
핵심코드  

```java
static void row() {
		for (int i = 0; i < N; i++) {
			int cnt = 1; //처음부터 cnt는 1 현재위치도 개수에 포함되어야하기때문에
			boolean flag = true; // 실패인지 성공인지 따지기 위한 변수
			boolean down = false; //내려가는 중인지 확인하는 변수
			int d = map[i][0]; //기준점

			for (int j = 0; j < N-1; j++) { //가로검사
				if(d != map[i][j+1]) {
					if(d+1 == map[i][j+1]) { //올라가는 경우
						if(down) { //내려가는 도중에 올라가려하면 활주로가 겹치므로 이 경우는 false
							flag = false;
							break;
						}
						else {
							if(cnt<X) { //올라가기 위해서는 지금까지 높이가 X만큼 연속되었는지를 확인해야한다. 그렇지 않다면 false
								flag = false;
								break;
							}
						}
					}else if(d-1==map[i][j+1]){ //내려가는 경우
              if(down) {//내려가고 있는데 또 내려가야한다면
							flag = false;
							break;
						}
						down = true; //내려가는 경우 이므로 down true
					}else { //수가 1이상  차이나는 경우
						flag = false;
						break;
					}
					cnt = 1; //기준점을 새로시작하므로 지금 칸부터 다시 연속하는지 세어야한다
					d = map[i][j+1]; //연속하지 않은 경우이므로 기준점을 변경해준다.
				}else { //연속했다면
					cnt++; //연속하므로 증가시켜주고
					if(down) { //연속하는중인데 내려가는 중이라면
						if(cnt>=X) { //X만큼 연속했는지 확인해주고
							down = false; //X만큼 달성했다면 내려가는 중이라는 건 바로 해제해준다.
							cnt = 0; //앞으로 세어야하므로 cnt는 0
						}
					}
				}

			}
			if(down && cnt < X) flag = false; //내려가는중인데 지형이 끝났고 X만큼 다리를 건설하지 못했다면 false다.
			if(flag) { //flag가 true인 경우만 세기
				ans++;
			}

		}
	}

```
### 틀린 부분 수정 or 다른 풀이  
틀렸던 부분 연속하는 경우에 cnt가 x만큼 되었다면 다시 down을 초기화해줘야하는것
그리고 down이라는 변수로 계속 내려가는 중인지를 확인해줘야한다는 점  

### 느낀점 or 기억할 정보  
올라갈때는 지금까지 X만큼 연속했는지를 봐야하고,
내려갈때는 앞으로 X만큼 연속할건지를 봐야한다.
만약 X만큼 달성하지 못하고 지형이 종료되면 검사 이후에 cnt가 x만큼 됐는지 확인해줘야한다.
