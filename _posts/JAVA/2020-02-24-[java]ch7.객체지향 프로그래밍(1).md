---
title: java ch7. 객체지향 프로그래밍 (1) - 상속  
description: 상속의 정의와 장점, 제어자    
categories:
 - JAVA
tags:
---  
# 상속  
## 상속의 정의와 장점  
상속 : 기존의 클래스를 재사용하여 새로운 클래스 작성  
장점 : 코드의 재사용성, 코드의 중복 제거, 프로그램의 생산성과 유지보수에 크게 기여  


* 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다  
* 자손 클래스의 멤버 개수는 조상 클래스보다 항상 많거나 같다  
* 접근 제어자로 private, default가 사용된 멤버들은 상속되지 않는다기보다 상속은 받지만 자손 클래스로부터의 접근이 제한되는 것  

## 클래스간의 관계 - 포함관계  
: 한 클래스의 멤버변수로 다른 클래스를 선언하는 것  

## 클래스간의 관계 결정하기  
상속관계 : ~은 ~이다  
포함관계 : ~은 ~을 가지고 있다  

## 단일상속  
자바는 단일 상속만 허용  
만약 다중상속이 가능하다면,  
조상클래스 2개에서 겹치는 메서드가 있다면 어떤 메서드를 호출해야할지 구별을 할 수 없으므로 단일 상속만 가능  

## Object클래스 - 모든 클래스의 조상  
toString()이나 equals(Object o)를 따로 정의하지 않고 사용할 수 있던 건 Object에 이메서드들이 정의되어있었기 때문에  

# 오버라이딩  
## 오버라이딩이란  
: 상속받은 메서드의 내용을 변경하는 것  

## 오버라이딩의 조건  
자손클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와  
이름이 같아야한다  
매개변수가 같아야한다  
리턴타입이 같아야한다  

1. 접근 제어자는 조상 클래스의 메서드보다 접은 범위로 변경할 수 없다.  
  조상 클래스에 정의된 메서드의 접근 제어자가 protected라면 자손클래스에서는 protected나 public이어야한다  

2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다  
  주의할 점은 단순히 선언된 예외의 개수가 문제가 아니라는 점  
  ```JAVA
  Class Child extends Parent{
    void parentMethod() throws Exception{

    }
  }
  ```  
  Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언한 것이다  

3. 인스턴스메서드를 static 메서드로 또는 그 반대로 변경할 수 없다  

## super  
: 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수  
모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다  
따라서 static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용가능하다  

## super() - 조상 클래스의 생성자    
자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다  
이 때 조상 클래스 멤버의 생성과 초기화 작업이 수행되어야 하므로 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다  

**생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유**
=> 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야한다  

조상 클래스 생성자의 호출은 최고 조상인 Object클래스의 생성자까지 가서야 끝난다  
모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야한다  그렇지 않으면 컴파일러가 자동으로 생성자의 첫줄에 super();를 추가한다  

# package와 import  
## 패키지  
: 클래스의 묶음  

클래스 - 물리적으로 하나의 클래스파일  
패키지 - 물리적으로 하나의 디렉토리  

* 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다  
* 모든 클래스는 반드시 하나의 패키지에 속해야한다  
* 패키지는 점(.)을 구분자로 하여 계층구조를 구성할 수 있다  
* 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리이다  

## 패키지의 선언  
소문자로 하는 것을 원칙으로 하고 있다  
클래스패스 : 컴파일러나 JVM이 클래스의 위치에 찾는데 사용되는 경로  

## import문  
import문으로 사용하려는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명 생략가능  
**import문의 역할** : 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것  
컴파일시, 컴파일러가  
import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여준다  

java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지므로  
따로 import문으로 지정하지 않아도 되도록 한 것  

# 제어자  
제어자 종류 2가지  
1. 접근 제어자 - public,protected,default,private  
2. 그 외 - static,final, abstract, native 등  

## static : 클래스의, 공통적인  
## final : 마지막의, 변경될 수 없는  
제어자 | 대상 | 의미  
--|--|--  
final | 클래스 | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이될 수 없다  
final| 메서드 | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다  
final| 멤버변수, 지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다

## 생성자를 이용한 final 멤버변수 초기화  
final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 **생성자**에서 초기화 되도록 할 수 있다  

이 기능을 활용하면 <U>각 인스턴스마다</u> final이 붙은 멤버변수가 <u>다른 값</u>을 갖도록 하는 것이 가능  

## abstract - 추상의, 미완성의  
제어자 | 대상 | 의미  
--|--|--  
abstract | 클래스 | 클래스 내에 추상메서드가 선언되어 있음을 의미한다  
abstract | 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상메서드  

## 접근 제어자  
해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할  

제어자 | 같은 클래스 | 같은 패키지 | 자손 클래스 | 전체  
----|------|------|-----|-----  
public|O|O|O|O  
protected|O|O|O|  
default|O|O||  
private|O|||  

```public > protected > default > private```  
protected는 패키지에 관계 없이 상속관계에 있는 자손클래스에서 접근 할 수 있다  

## 접근 제어자를 이용한 캡슐화  
접근 제어자를 사용하는 이유  
* 외부로부터 데이터를 보호하기 위해서  
* 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서  

참고) 하나의 소스파일에는 public 클래스가 단 하나만 존재할 수 있으며, 소스파일의 이름은 반드시 public클래스의 이름과 같아야한다  

## 생성자의 접근제어자  
보통 <u>생성자의 접근 제어자</u>는 <u>클래스이 접근제어자</u>와 같지만, 다르게 지정 가능  

생성자의 접근 제어자를 private으로 지정하면 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게된다. 그러나 클래스 내부에서는 인스턴스의 생성이 가능하다  

```java  
class Singleton{
  private static Singleton s = new Singleton();
  //getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static으로 지정  

  private Sigleton(){

  }

  //인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다  
  public static Singleton getInstance(){
    return s;
  }

}
```  

생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다  
왜냐하면, 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야하만 하는데, 생성자의 접근 제어자가 private이므로 <U>자손클래스에서 호출하는 것이 불가능</u>하므로  
그래서 클래스에 final을 붙여 상속할 수 없는 클래스라는 것을 명시해야한다  

## 제어자의 조합  
대상 | 사용가능한 제어자  
--|--
클래스 | public, default, final, abstract  
메서드 | 모든 접근 제어자, final, abstract, static  
멤버변수 | 모든 접근 제어자, final, static  
지역변수 | final  

* inner class는 static을 붙일 수 있다  

### 제어자 조합 주의사항  
1. 메서드 static과 abstract를 함께 사용할 수 없다  
  static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문  

2. 클래스 abstract와 final을 동시에 사용할 수 없다  
  클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미고, abstract는 상속을 통해서 완성되어야 하므로 <u>서로 모순</u>된다  
3. abstract메서드의 접근 제어자가 private일 수 없다  
  abstract메서드는 자손클래스에서 구현해줘야하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문  
4. 메서드에 private과 final을 같이 사용할 필요는 없다  
  접근제어자 private메서드는 오버라이딩될 수 없기 때문에, <u>둘 중 하나만 사용해도 의미 충분</u>  
