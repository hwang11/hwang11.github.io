---
title: java ch7. 객체지향 프로그래밍 (2) - 다형성    
description: 다형성, 참조변수의 형변환, instanceof      
categories:
 - JAVA
tags:
---  
# 인터페이스  
## 인터페이스란  
추상화클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서  
 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다  
 오직 **추상메서드**와 **상수**만을 멤버로 가질 수 있다  

## 인터페이스의 작성  
클래스처럼 접근제어자로 public 또는 default를 사용할 수 있다  
* 모든 멤버변수는 public static final이어야하며 생략가능  
* 모든 메서드는 public abstract 이어야하며 생략가능  

인터페이스에 정의돈 모든 멤버에 예외없이 적용되는 사항이기 때문에 제어자를 생략할 수 있는 것이며 편의상 생략하는 경우가 많다. 생략된 제어자는 컴파일 시 컴파일러가 자동적으로 추가해준다  

## 인터페이스의 상속  
인터페이스는 인터페이스로부터만 상속받을 수 있다  
다중상속이 가능하다  
클래스와 달리 Object클래스와 같은 최고 조상은 없다  

## 인터페이스의 구현  
* implements 사용  
* 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, 추상클래스로 선언되어야 한다  

* 인터페이스의 이름에 주로 ~able로 끝나는 것들이 많다  

* 오버라이딩 할 때 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야한다.  
따라서 인터페이스의 추상메서드를 오버라이딩할 때 구현체 메서드의 접근 제어자를 public으로 해야한다  

## 인터페이스를 이용한 다중상속  
자바에서 인터페이스로 다중상속을 구현하는 경우는 거의 없다  

## 인터페이스를 이용한 다형성  
인터페이스는 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다  
```JAVA
void attack(Fightable f){}

```  
메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다  

## 인터페이스의 장점  
#### 1. 개발시간을 단축시킬 수 있다  
  인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다  
  메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문   
  한쪽에선 인터페이스를 구현하고, 한쪽에선 구현클래스 완성을 기다리지않고도 동시에 개발이 가능하다  
#### 2. 표준화가 가능하다  
  프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 일관되고 정형화된 프로그램의 개발 가능  

#### 3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다  
  서로 상속관계에 있지않고, 같은 조상클래스를 갖지도 않은 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다  

#### 4. 독립적인 프로그래밍이 가능하다  
  인터페이스를 이용하면 클래스의 선언과 구현을 분리시키기때문에 실제구현에 독립적인 프로그램 작성이 가능하다  
  클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면,  
  한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다  

## 인터페이스의 이해  
* 클래스를 사용한 쪽(User)과 클래스를 제공하는 쪽(Provider)가 있다  
* 메서드 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면된다  

```JAVA
class A{
  public void methodA(B b){
    b.methodB();
  }
}

class B{
  public void methodB(){

  }
}

class Test{
  public static void main(String args[]){
    A a = new A();
    a.methodA(new B());
  }
}

```  
이 경우 클래스 A를 작성하기 위해서는 클래스 B가 **이미** 작성되어 있어야 한다.  
그리고 methodB()의 선언부가 변경되면 이를 사용하는 클래스 A도 변경되어야한다  
이와 같이 직접적인 관계의 두 클래스는 한 쪽(Provider)가 변경되면 다른 한쪽(User)도 변경되어야 한다는 단점이 있다  

그러나,  
클래스 A가 B를 직접 호출하지 않고 <u>인터페이스를 매개체</u>로 해서 클래스 A가 인터페이스를 통해서 클래스 B의 메서드에 접근하도록 하면   
클래스 B의 변경사항이 A에 영향을 미치지 않을 것이다  

```JAVA
class A{
  void autoplay(I i){
    i.play();
  }
}

interface I{
  public abstract void play();
}

class B implements I{
  public void play(){

  }
}

class C implements I{
  public void play(){

  }
}

class Test{
  public static void main(String args[]){
    A a = new A();
    a.autoplay(new B());
    a.autoplay(new C());
  }
}
```  
이처럼 매개변수를 통해서 인터페이스 I를 구현한 클래스의 인스턴스를 동적으로 제공받아야 한다  
위의 코드에서 클래스 A는 B나 C에 대해서 알필요가 없다  
