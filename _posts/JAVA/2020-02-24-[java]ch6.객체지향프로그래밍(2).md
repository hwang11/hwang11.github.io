---
title: java ch6. 객체지향 프로그래밍 (2)
description: java ch6. 객체지향 프로그래밍 (2)  
categories:
 - JAVA
tags:
---  
# 메서드 오버로딩  
## 메서드 오버로딩이란  
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것  

## 오버로딩 조건  
* 메서드 이름 동일  
* 매개변수의 개수 or 타입이 달라야한다  
* 매개변수는 같고 리턴타입이 다른 경우 오버로딩 성립X  
* 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있다  

ex)  
```long add(int a,long b){return a+b;}```  
```long add(long a,int b){return a+b;}```  

두 메서드는 오버로딩으로 간주한다  
그러나 이처럼 매개변수의 순서만 다르게 할 경우 오히려 단점이 될 수 있다  
```add(3,3L)``` : 첫번째 메서드 호출  
```add(3L, 3)``` :두번째 메서드 호출  
```add(3,3)``` 의 경우 두 메서드 중 어느 메서드가 호출된 것인지 알 수 없기 때문에
메서드를 호출하는 곳에서 컴파일 에러발생  

## 오버로딩 장점  
println()은 매개변수타입이 모두 다르게 정의되어있지만,  
기능은 출력한다는 것으로 동일하다  
이 때 println()이라는 메서드 명만 기억하면 되므로 이름도 짧고 기억하기 쉬운 장점이 있다  

# 생성자  
: 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드  
* 생성자의 이름은 클래스의 이름과 같아야 한다  
* 생성자는 리턴 값이 없다  
* 생성자도 오버로딩 가능  

연산자 new가 인스턴스를 생성하는 것, 생성자가 인스턴스를 생성하는 것은 X  
생성자는 단순히 인스턴스변수들의 초기화에 사용되는 메서드  

```Card c = new Card();```  
1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다  
2. 생성자 Card()가 호출되어 수행된다  
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다  

## 기본 생성자  
컴파일 할 때, 소스파일의 클래스에 생성자가 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일한다  
```JAVA  
class Data1{
  int value;
}
class Data2{
  int value;
  Data2(int x){
    value = x;
  }
}
class Test{
  public static void main(String args[]){
    Data1 d1 = new Data1();
    Data2 d2 = new Data2();
  }
}

```  
컴파일 결과 컴파일 에러가 발생한다  
이유는 Data2의 Data2() 생성자가 없는데 호출했기 때문이다  
Data1의 경우 정의된 생성자가 없으므로 기본생성자를 컴파일러가 알아서 생성한다  

```기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다```  


## 생성자에서 다른 생성자 호출하기 - this(),this  
* 생성자의 이름으로 클래스이름 대신 this를 사용한다  
* 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능하다  
  - 이유는 생성자 내에서 초기화 작업도중 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문  

```this``` : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다  
  모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다  
```this(), this(매개변수)``` : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용   

### 인스턴스를 생성할 때 2가지 사항을 결정해야한다  
1. 클래스 : 어떤 클래스의 인스턴스를 생성할 것인가?  
2. 생성자 : 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?  

# 변수의 초기화  
## 변수의 초기화  
멤버 변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어짐  
그러나, 지역변수는 사용하기 전에 반드시 초기화 필요  
```java
class InitTest{
  int x;
  int y = x;
  void method1(){
    int i;
    int j = i; //컴파일에러 지역변수 i를 초기화하지 않고 사용함  
  }
}

```
### 각 자료형의 기본값  
자료형 | 기본값  
--|--  
boolean | false
char | '\u0000'  
byte | 0  
short | 0
int | 0  
long | 0L  
float | 0.0f  
double | 0.0d 또는 0.0  
참조형변수 | null  

### 멤버변수의 초기화 방법  
1. 명시적 초기화  
2. 생성자  
3. 초기화 블럭
  * 인스턴스 초기화 블럭  
  * 클래스 초기화 블럭  

## 명시적 초기화  
선언과 동시에 초기화 하는것  
```int door = 4;```  
## 초기화 블럭  
```java
class InitBlock{
  static { 클래스초기화 블럭 }
  {인스턴스 초기화 블럭  
  }
}

```
* 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행  
* 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행  
* 생성자보다 인스턴스 초기화 블럭이 먼저 수행   

인스턴스변수의 초기화는 주로 생성자를 사용하므로 블럭을 잘 안쓴다  

배열이나 예외처리가 필요한 초기화에서 클래스 초기화 블럭을 주로 사용  

## 멤버변수의 초기화 시기와 순서  
```클래스변수의 초기화 시점``` : 클래스가 처음 로딩될 때 단 한번 초기화 된다  
```인스턴스변수의 초기화 시점``` : 인스턴스가 생성될 때 마다 각 인스턴스별로 초기화가 이루어진다  

```클래스변수의 초기화 순서``` : 기본값 - 명시적초기화 - 클래스 초기화블럭  
```인스턴스변수의 초기화 순서``` : 기본값 - 명시적초기화 - 인스턴스 초기화블럭 - 생성자  

* 클래스의 로딩시기는 JVM의 종류마다 다를 수 있다.  
클래스가 필요할 때 바로 메모리에 로딩하도록 설계가 되어있는 것도 있고, 실행효율을 높이기 위해 사용될 클래스들을 프로그램이 시작될 때 미리 로딩하도록 되어있는 것도 있다  
