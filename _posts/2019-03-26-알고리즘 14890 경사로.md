---
title: 알고리즘 14890 경사로
description: 알고리즘 14890 경사로
categories:
 - 알고리즘  
tags:
---
## 14890 경사로  
### 문제 분석 요약  
길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다.  
또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다.   
경사로는 높이가 항상 1이며, 길이는 L이다.  

**조건**
* 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
* 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
* 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.  

### 알고리즘 설계  
**시뮬레이션**  
잘 모르겠어서 보고풀었다.  
경사로를 놓으려면 높이가 1 차이가 나야하는데  
현재를 기준으로 더 낮은 곳이 나올수도있고 더 높은 곳이 나올 수도 있다.  
이 2가지 경우를 각각 나눠서 구현해야한다.  

### 구현순서  
N개의 행, N개의 열을 각각 확인하고 개수를 세면된다.  

### 코드  
```java
static void solve() {
	for(int n=0;n<N;n++) {
		int i = 0;
		int cnt = 1;
		for(i=0;i<N-1;i++) {
			if(a[n][i] == a[n][i+1]) cnt++;
      //같으면 개수를 세준다. 이게 나중에 경사로를 만들 만큼 쌓였는지 기준이 되므로

			else if(a[n][i]-1 == a[n][i+1] && cnt >= 0) cnt = -L+1;
      //현재 보다 작은 곳을 만나면 앞으로 경사로를 놓을만큼 cnt를 증가시켜야한다.
      //그만큼이 되기까지 L만큼 필요하므로 cnt = L + 1을 넣어준다.

			else if(a[n][i]+1 == a[n][i+1] && cnt >= L) cnt = 1;
      // 현재보다 큰걸 만나면 내가 그전에 경사로를 놓을 만큼 연속되어왔는지 확인해야한다  
      //그다음 다시 cnt = 1로 만들어 준다 거기서부터 다시 세야되므로

			else break; //이 조건에 해당이안되면 나온다.
		}
		if(i==N-1 && cnt>= 0) { //i가 N-1이 되기전에 나오면 실패다.
      //그리고 cnt가 음수라면 앞으로 경사로를 놓아야하는 상황이므로 실패다.
			ans++;
		}
		cnt = 1;
		for(i=0;i<N-1;i++) {
			if(a[i][n] == a[i+1][n]) cnt++;
			else if(a[i][n]-1 == a[i+1][n] && cnt >= 0) cnt = -L+1;
			else if(a[i][n]+1 == a[i+1][n] && cnt >= L) cnt = 1;
			else break;
		}
		if(i==N-1 && cnt>= 0) {
			ans++;
		}
	}
}
```
### 틀린 부분 수정 or 다른 풀이  
반복적으로 확인해줘야된다고 생각해서 재귀로 풀려고 생각함.. 끔찍..  

### 느낀점 or 기억할 정보  
이걸 직접 구현할 수 있을지 모르겠다. 어렵다.
